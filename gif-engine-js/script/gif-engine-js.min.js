const GIF=(()=>{const a=Symbol(),b=Symbol(),c=async function(h,j=!1){if(!(Number.isInteger(h)&&-1<h))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");if(this.frames[h].data)return this.frames[h].data;const{rawData:k,minCodeSize:m,descriptor:{width:n,height:q}}=this.frames[h],r=n*q,s=Array(r),t=Array(4096),u=Array(4096),v=Array(4097),w=1<<m;let z=w+2,A=-1,B=m+1,C=(1<<B)-1,D=0;for(;w>D;++D)t[D]=0,u[D]=D;let K,E=0,F=0,G=0,H=0,I=0,J=0;for(let L=0;r>L;){if(0==H){if(B>F){E+=k[I]<<F,F+=8,++I;continue}if(D=E&C,E>>=B,F-=B,D>z||D===w+1)break;if(D==w){B=m+1,C=(1<<B)-1,z=w+2,A=-1;continue}if(-1==A){v[H]=u[D],++H,A=D,G=D;continue}for(K=D,D==z&&(v[H]=G,D=A,++H);D>w;)v[H]=u[D],D=t[D],++H;G=255&u[D],v[H]=G,++H,4096>z&&(t[z]=A,u[z]=G,0==(++z&C)&&4096>z&&(++B,C+=z)),A=K}s[J]=v[--H],++J,++L}for(let L=J;r>L;++L)s[L]=0;return j&&(this.frames[h].rawData=void 0),this.frames[h].data=s},d=async function(h,j=!1){if(!(Number.isInteger(h)&&-1<h))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");const k=this.frames[h];if(0===k.descriptor.packed.interlaceFlag)throw new TypeError("Can't deinterlace a non-interlaced frame");if(this[b])return k.deinterlacedData;k.data||(await this.inflate(h,!0));const{descriptor:{width:n},data:m,data:{length:q}}=k,s=Array(q),t=[0,4,2,1],u=[8,8,4,2];let v=-1;for(let w=0;4>w;++w)for(let y=t[w];q/n>y;y+=u[w])s.splice(y*n,n,...m.slice(++v*n,(v+1)*n));return j?(k.data=s,k.deinterlacedData=null):k.deinterlacedData=s,Object.defineProperty(this,b,{value:!0}),s},f=async function(h){if(!(Number.isInteger(h)&&-1<h))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");const j=this.frames[h];j.data||(await this.inflate(h,!0)),1!==j.descriptor.packed.interlaceFlag||this[b]||(await this.deinterlace(h,!0));const k=j.deinterlacedData||j.data,{width:m,height:n,left:q,top:r}=j.descriptor,s=m*n,t=new Uint8ClampedArray(4*s),u=j.descriptor.packed.localColorTableFlag?j.localColorTable:this.globalColorTable,{transparentColorIndex:v}=j.graphicExtension;for(let w=0,y=-1;s>w;++w){let z=k[w],A=u[z];t[++y]=A[0],t[++y]=A[1],t[++y]=A[2],t[++y]=z===v?0:255}return[new ImageData(t,m,n),q,r]};return async function(h,j=!1){const k=performance.now(),m=h.byteLength,n=j?console.log:()=>{},q=new Uint8Array(h);let r=5;n("GIF >"),n("| Logical Screen Descriptor");const s=Object.defineProperties({descriptor:{width:q[++r]|q[++r]<<8,height:q[++r]|q[++r]<<8,packed:{globalColorTableFlag:(128&q[++r])>>7,colorResolution:(64&q[r]|32&q[r]|16&q[r])>>4,sortFlag:(8&q[r])>>3,size:4&q[r]|2&q[r]|1&q[r]},backgroundColorIndex:q[++r],pixelAspectRatio:q[++r]},globalColorTable:void 0,repeat:0,frames:[]},{[a]:{value:!0},inflate:{value:c},deinterlace:{value:d},toImageData:{value:f}});if(s.descriptor.packed.globalColorTableFlag){n("| Global Color Table");const y=2**(s.descriptor.packed.size+1),z=new Uint8Array(h,++r,3*y),A=Array(y);for(let B=0,C=0;y>B;++B,r+=3)A[B]=[,,,],C=-1,A[B][++C]=z[3*B+C],A[B][++C]=z[3*B+C],A[B][++C]=z[3*B+C];s.globalColorTable=A}else++r;let t=0;const u=()=>({graphicExtension:void 0,deinterlacedData:void 0,localColorTable:void 0,minCodeSize:void 0,descriptor:void 0,rawData:void 0,data:void 0}),v=[78,69,84,83,67,65,80,69,50,46,48];let w;loop:for(;m>r;)switch(q[r]){case 33:switch(n("| Extension"),q[++r]){case 249:{n("| | Graphics Control");const y=q[++r];let z=0,A=new Uint8Array(h,++r,y);if(0!==q[r+=y]){w="missing null";break loop}s.frames[t]||(s.frames[t]=u());let B;s.frames[t].graphicExtension={disposalMethod:(16&A[z]|8&A[z]|4&A[z])>>2,userInputFlag:(2&A[z])>>1,transparentColorFlag:B=1&A[z],delay:10*(A[++z]|A[++z]<<8),transparentColorIndex:B?A[++z]:(++z,0)}}break;case 255:{n("| | Application");const y=q[++r];if(11!==y){w="app extension header of 11 byte length expected";break loop}let z=!0;for(let A=0;y>A&&z;++A)z=v[A]===q[1+A+r];if(z){if(1!==q[r+=y+2]){w="invalid NETSCAPE block";break loop}if(s.repeat=q[++r]|q[++r]<<8,0!==q[++r]){w="missing null";break loop}}else{for(;0!==q[++r];);++r}}break;case 254:case 1:for(;0!==q[++r];)r+=q[r];break;default:w="unknown extension";break loop;}++r;break;case 44:{s.frames[t]||(s.frames[t]=u()),n(`| Image Descriptor #${1+t}`);let y=0,z=0;if(s.frames[t].descriptor={left:q[++r]|q[++r]<<8,top:q[++r]|q[++r]<<8,width:q[++r]|q[++r]<<8,height:q[++r]|q[++r]<<8,packed:{localColorTableFlag:y=(128&q[++r])>>7,interlaceFlag:(64&q[r])>>6,sortFlag:(32&q[r])>>5,size:z=4&q[r]|2&q[r]|1&q[r]}},1==y){n("| Local Color Table");const F=2**(z+1),G=new Uint8Array(h,++r,3*F),H=Array(F);for(let I=0,J=0;F>I;++I,r+=3)H[I]=[,,,],J=-1,H[I][++J]=G[3*I+J],H[I][++J]=G[3*I+J],H[I][++J]=G[3*I+J];s.frames[t].localColorTable=H,--r}n("| Image Data");const A=q[++r];if(8<A||2>A){w="invalid LZW minimum code size";break loop}s.frames[t].minCodeSize=A;let B=-1;const C=++r;for(n("| | Counting total sub-block length");0!==q[r];){const F=q[r];B+=F,r+=F+1}n("| | Processing sub-block");const D=Array(B);let E=-1;for(r=C;0!==q[r];){const F=q[r];for(let G=0;F>G;++G)D[++E]=q[++r];++r}s.frames[t].rawData=D,n(`| | Sub-block processed`),++r,n(`| Frame #${++t} processed`)}break;case 59:n(`GIF processed in ${performance.now()-k} ms`),++r;break loop;default:w="unknown block";break loop;}if(w)throw new TypeError(`${w}\n0x${q[r].toString(16).toUpperCase().padStart(2,0)} @ 0x${r.toString(16).toUpperCase().padStart(8,0)}`);return r!==m&&n(`/!\\ Additional ${m-r} bytes of data after tail ignored`),s}})();if(!(()=>{try{return!!window.document.documentElement}catch(a){return!1}})()){const a=(...b)=>postMessage(["log",...b]);this.onmessage=b=>{let d=0,f=-1,g,h,j=0,k=0;fetch(b.data,{headers:{pragma:"no-cache","cache-control":"no-cache"}}).then(m=>m.arrayBuffer()).then(GIF).then(async m=>{a(m);d=m.frames.length,g=Array(d),h=m.frames.map(s=>s.graphicExtension.delay-1);const q=m.frames.map(s=>s.graphicExtension.disposalMethod);({width:j,height:k}=m.descriptor);for(const r=new Uint8ClampedArray(4*(j*k));++f<d;){const[{data:u,width:v,height:w},s,t]=await m.toImageData(f);switch(q[f]){case 2:for(let y=0;w>y;++y)for(let A,z=0;v>z;++z)A=4*(z+s+(y+t)*j),r[A]=0,r[++A]=0,r[++A]=0,r[++A]=0;break;case 3:if(0<f){const[{data:A,width:B,height:C},y,z]=g[f-1];for(let D=0,E=-1;C>D;++D)for(let G,F=0;B>F;++F)G=4*(F+y+(D+z)*j),r[G]=A[++E],r[++G]=A[++E],r[++G]=A[++E],r[++G]=A[++E]}}for(let y=0,z=-1;w>y;++y)for(let B,A=0;v>A;++A){if(B=4*(A+s+(y+t)*j),0===u[z+4]){z+=4;continue}r[B]=u[++z],r[++B]=u[++z],r[++B]=u[++z],r[++B]=u[++z]}for(let y=0,z=-1;w>y;++y)for(let B,A=0;v>A;++A)B=4*(A+s+(y+t)*j),u[++z]=r[B],u[++z]=r[++B],u[++z]=r[++B],u[++z]=r[++B];g[f]=[new ImageData(u,v,w),s,t]}postMessage([g,h,j,k])})["catch"](a)}}