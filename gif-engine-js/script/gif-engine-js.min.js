const GIF=(()=>{const a=Symbol(),b=Symbol(),c=async function(g,h=!1){if(!(Number.isInteger(g)&&-1<g))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");if(this.frames[g].data)return this.frames[g].data;const{rawData:j,minCodeSize:k,descriptor:{width:m,height:n}}=this.frames[g],o=m*n,q=Array(o),r=Array(4096),s=Array(4096),t=Array(4097),u=1<<k;let w=u+2,x=-1,y=k+1,z=(1<<y)-1,A=0;for(;u>A;++A)r[A]=0,s[A]=A;let H,B=0,C=0,D=0,E=0,F=0,G=0;for(let I=0;o>I;++I){if(0==E){if(y>C){B+=j[F]<<C,C+=8,++F;continue}if(A=B&z,B>>=y,C-=y,A>w||A===u+1)break;if(A==u){y=k+1,z=(1<<y)-1,w=u+2,x=-1;continue}if(-1==x){t[E]=s[A],++E,x=A,D=A;continue}for(H=A,A==w&&(t[E]=D,A=x,++E);A>u;)t[E]=s[A],A=r[A],++E;D=255&s[A],t[E]=D,++E,4096>w&&(r[w]=x,s[w]=D,0==(++w&z)&&4096>w&&(++y,z+=w)),x=H}q[G]=t[--E],++G}for(let I=G;o>I;++I)q[I]=0;return h&&(this.frames[g].rawData=void 0),this.frames[g].data=q},d=async function(g,h=!1){if(!(Number.isInteger(g)&&-1<g))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");const j=this.frames[g];if(0===j.descriptor.packed.interlaceFlag)throw new TypeError("Can't deinterlace a non-interlaced frame");if(this[b])return j.deinterlacedData;j.data||(await this.inflate(g,!0));const{descriptor:{width:m},data:k,data:{length:n}}=j,q=Array(n),r=[0,4,2,1],s=[8,8,4,2];let t=-1;for(let u=0;4>u;++u)for(let v=r[u];n/m>v;v+=s[u])q.splice(v*m,m,...k.slice(++t*m,(t+1)*m));return h?(j.data=q,j.deinterlacedData=null):j.deinterlacedData=q,Object.defineProperty(this,b,{value:!0}),q},e=async function(g){if(!(Number.isInteger(g)&&-1<g))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");const h=this.frames[g];h.data||(await this.inflate(g,!0));const j=1===h.descriptor.packed.interlaceFlag;j&&!this[b]&&(await this.deinterlace(g,!0));const k=h.deinterlacedData||h.data,{length:m}=k,n=new Uint8ClampedArray(4*m),o=h.descriptor.packed.localColorTableFlag?h.localColorTable:this.globalColorTable,{transparentColorIndex:q}=h.graphicExtension;for(let t,r=0,s=-1;m>r;++r)t=o[k[r]],n[++s]=t[0],n[++s]=t[1],n[++s]=t[2],n[++s]=r!==q?255:0;return new ImageData(n,h.descriptor.width,h.descriptor.height)};return async function(g,h=!1){const j=performance.now(),k=g.byteLength,m=h?console.log:()=>{},n=new Uint8Array(g);let o=5;m("GIF >"),m("| Logical Screen Descriptor");const q=Object.defineProperties({descriptor:{width:n[++o]|n[++o]<<8,height:n[++o]|n[++o]<<8,packed:{globalColorTableFlag:(128&n[++o])>>7,colorResolution:(64&n[o]|32&n[o]|16&n[o])>>4,sortFlag:(8&n[o])>>3,size:4&n[o]|2&n[o]|1&n[o]},backgroundColorIndex:n[++o],pixelAspectRatio:n[++o]},globalColorTable:void 0,repeat:0,frames:[]},{[a]:{value:!0},inflate:{value:c},deinterlace:{value:d},toImageData:{value:e}});if(q.descriptor.packed.globalColorTableFlag){m("| Global Color Table");const u=2**(q.descriptor.packed.size+1),v=new Uint8Array(g,++o,3*u),w=Array(u);for(let x=0,y=0;u>x;++x,o+=3)w[x]=[,,,],y=-1,w[x][++y]=v[3*x+y],w[x][++y]=v[3*x+y],w[x][++y]=v[3*x+y];q.globalColorTable=w}else++o;let r=0;const s=()=>({graphicExtension:void 0,deinterlacedData:void 0,localColorTable:void 0,minCodeSize:void 0,descriptor:void 0,rawData:void 0,data:void 0});let t;loop:for(;k>o;)switch(n[o]){case 33:switch(m("| Extension"),n[++o]){case 249:{m("| | Graphics Control");const u=n[++o];let v=0,w=new Uint8Array(g,++o,u);if(0!==n[o+=u]){t="missing null";break loop}q.frames[r]||(q.frames[r]=s());let x;q.frames[r].graphicExtension={disposalMethod:(16&w[v]|8&w[v]|4&w[v])>>2,userInputFlag:(2&w[v])>>1,transparentColorFlag:x=1&w[v],delay:10*(w[++v]|w[++v]<<8),transparentColorIndex:x?w[++v]:(++v,0)}}break;case 255:{m("| | Application");const u=n[++o];if(11!==u){t="app extension of 11 byte length expected";break loop}if(1!==n[o+=u+2]){t="invalid app extension sub-block";break loop}if(q.repeat=n[++o]|n[++o]<<8,0!==n[++o]){t="missing null";break loop}}break;case 254:case 1:for(;0!==n[++o];)o+=n[o];break;default:t="unknown extension";break loop;}++o;break;case 44:{q.frames[r]||(q.frames[r]=s()),m(`| Image Descriptor #${1+r}`);let u=0,v=0;if(q.frames[r].descriptor={left:n[++o]|n[++o]<<8,top:n[++o]|n[++o]<<8,width:n[++o]|n[++o]<<8,height:n[++o]|n[++o]<<8,packed:{localColorTableFlag:u=(128&n[++o])>>7,interlaceFlag:(64&n[o])>>6,sortFlag:(32&n[o])>>5,size:v=4&n[o]|2&n[o]|1&n[o]}},1==u){m("| Local Color Table");const B=2**(v+1),C=new Uint8Array(g,++o,3*B),D=Array(B);for(let E=0,F=0;B>E;++E,o+=3)D[E]=[,,,],F=-1,D[E][++F]=C[3*E+F],D[E][++F]=C[3*E+F],D[E][++F]=C[3*E+F];q.frames[r].localColorTable=D,--o}m("| Image Data");const w=n[++o];if(8<w||2>w){t="invalid LZW minimum code size";break loop}q.frames[r].minCodeSize=w;let x=-1;const y=++o;for(m("| | Counting total sub-block length");0!==n[o];){const B=n[o];x+=B,o+=B+1}m("| | Processing sub-block");const z=Array(x);let A=-1;for(o=y;0!==n[o];){const B=n[o];for(let C=0;B>C;++C)z[++A]=n[++o];++o}q.frames[r].rawData=z,m(`| | Sub-block processed`),++o,m(`| Frame #${++r} processed`)}break;case 59:m(`GIF processed in ${performance.now()-j} ms`),++o;break loop;default:t="unknown block";break loop;}if(t)throw new TypeError(`${t}\n0x${n[o].toString(16).toUpperCase().padStart(2,0)} @ 0x${o.toString(16).toUpperCase().padStart(8,0)}`);return o!==k&&m(`/!\\ Additional ${k-o} bytes of data after tail ignored`),q}})();