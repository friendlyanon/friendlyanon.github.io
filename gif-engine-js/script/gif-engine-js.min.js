const GIF=(()=>{const a=Symbol(),b=Symbol(),c=async function(k,m=!1){if(!(Number.isInteger(k)&&-1<k))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");if(this.frames[k].data)return this.frames[k].data;const{rawData:n,minCodeSize:q,descriptor:{width:r,height:s}}=this.frames[k],t=r*s,u=Array(t),v=Array(4096),y=Array(4096),z=Array(4097),A=1<<q;let C=A+2,D=-1,E=q+1,F=(1<<E)-1,G=0;for(;A>G;++G)v[G]=0,y[G]=G;let N,H=0,I=0,J=0,K=0,L=0,M=0;for(let O=0;t>O;){if(0==K){if(E>I){H+=n[L]<<I,I+=8,++L;continue}if(G=H&F,H>>=E,I-=E,G>C||G===A+1)break;if(G==A){E=q+1,F=(1<<E)-1,C=A+2,D=-1;continue}if(-1==D){z[K]=y[G],++K,D=G,J=G;continue}for(N=G,G==C&&(z[K]=J,G=D,++K);G>A;)z[K]=y[G],G=v[G],++K;J=255&y[G],z[K]=J,++K,4096>C&&(v[C]=D,y[C]=J,0==(++C&F)&&4096>C&&(++E,F+=C)),D=N}u[M]=z[--K],++M,++O}for(let O=M;t>O;++O)u[O]=0;return m&&(this.frames[k].rawData=void 0),this.frames[k].data=u},d=async function(k,m=!1){if(!(Number.isInteger(k)&&-1<k))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");const n=this.frames[k];if(0===n.descriptor.packed.interlaceFlag)throw new TypeError("Can't deinterlace a non-interlaced frame");if(this[b])return n.deinterlacedData;n.data||(await this.inflate(k,!0));const{descriptor:{width:r},data:q,data:{length:s}}=n,u=Array(s),v=[0,4,2,1],y=[8,8,4,2];let z=-1;for(let A=0;4>A;++A)for(let B=v[A];s/r>B;B+=y[A])u.splice(B*r,r,...q.slice(++z*r,(z+1)*r));return m?(n.data=u,n.deinterlacedData=null):n.deinterlacedData=u,Object.defineProperty(this,b,{value:!0}),u},f=async function(k){if(!(Number.isInteger(k)&&-1<k))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");const m=this.frames[k];m.data||(await this.inflate(k,!0)),1!==m.descriptor.packed.interlaceFlag||this[b]||(await this.deinterlace(k,!0));const n=m.deinterlacedData||m.data,{width:q,height:r,left:s,top:t}=m.descriptor,u=q*r,v=new Uint8ClampedArray(4*u),y=m.descriptor.packed.localColorTableFlag?m.localColorTable:this.globalColorTable,{transparentColorIndex:z}=m.graphicExtension;for(let A=0,B=-1;u>A;++A){let C=n[A],D=y[C];v[++B]=D[0],v[++B]=D[1],v[++B]=D[2],v[++B]=C===z?0:255}return[new ImageData(v,q,r),s,t]};return async function(k,m=!1){const n=performance.now(),q=k.byteLength,r=m?console.log:()=>{},s=new Uint8Array(k);let t=5;r("GIF >"),r("| Logical Screen Descriptor");const u=Object.defineProperties({descriptor:{width:s[++t]|s[++t]<<8,height:s[++t]|s[++t]<<8,packed:{globalColorTableFlag:(128&s[++t])>>7,colorResolution:(64&s[t]|32&s[t]|16&s[t])>>4,sortFlag:(8&s[t])>>3,size:4&s[t]|2&s[t]|1&s[t]},backgroundColorIndex:s[++t],pixelAspectRatio:s[++t]},globalColorTable:void 0,repeat:0,frames:[]},{[a]:{value:!0},inflate:{value:c},deinterlace:{value:d},toImageData:{value:f}});if(u.descriptor.packed.globalColorTableFlag){r("| Global Color Table");const B=2**(u.descriptor.packed.size+1),C=new Uint8Array(k,++t,3*B),D=Array(B);for(let E=0,F=0;B>E;++E,t+=3)D[E]=[,,,],F=-1,D[E][++F]=C[3*E+F],D[E][++F]=C[3*E+F],D[E][++F]=C[3*E+F];u.globalColorTable=D}else++t;let v=0;const y=()=>({graphicExtension:void 0,deinterlacedData:void 0,localColorTable:void 0,minCodeSize:void 0,descriptor:void 0,rawData:void 0,data:void 0}),z=[78,69,84,83,67,65,80,69,50,46,48];let A;loop:for(;q>t;)switch(s[t]){case 33:switch(r("| Extension"),s[++t]){case 249:{r("| | Graphics Control");const B=s[++t];let C=0,D=new Uint8Array(k,++t,B);if(0!==s[t+=B]){A="missing null";break loop}u.frames[v]||(u.frames[v]=y());let E;u.frames[v].graphicExtension={disposalMethod:(16&D[C]|8&D[C]|4&D[C])>>2,userInputFlag:(2&D[C])>>1,transparentColorFlag:E=1&D[C],delay:10*(D[++C]|D[++C]<<8),transparentColorIndex:E?D[++C]:(++C,0)}}break;case 255:{r("| | Application");const B=s[++t];if(11!==B){A="app extension header of 11 byte length expected";break loop}let C=!0;for(let D=0;B>D&&C;++D)C=z[D]===s[1+D+t];if(C){if(1!==s[t+=B+2]){A="invalid NETSCAPE block";break loop}if(u.repeat=s[++t]|s[++t]<<8,0!==s[++t]){A="missing null";break loop}}else{for(;0!==s[++t];);++t}}break;case 254:case 1:for(;0!==s[++t];)t+=s[t];break;default:A="unknown extension";break loop;}++t;break;case 44:{u.frames[v]||(u.frames[v]=y()),r(`| Image Descriptor #${1+v}`);let B=0,C=0;if(u.frames[v].descriptor={left:s[++t]|s[++t]<<8,top:s[++t]|s[++t]<<8,width:s[++t]|s[++t]<<8,height:s[++t]|s[++t]<<8,packed:{localColorTableFlag:B=(128&s[++t])>>7,interlaceFlag:(64&s[t])>>6,sortFlag:(32&s[t])>>5,size:C=4&s[t]|2&s[t]|1&s[t]}},1==B){r("| Local Color Table");const I=2**(C+1),J=new Uint8Array(k,++t,3*I),K=Array(I);for(let L=0,M=0;I>L;++L,t+=3)K[L]=[,,,],M=-1,K[L][++M]=J[3*L+M],K[L][++M]=J[3*L+M],K[L][++M]=J[3*L+M];u.frames[v].localColorTable=K,--t}r("| Image Data");const D=s[++t];if(8<D||2>D){A="invalid LZW minimum code size";break loop}u.frames[v].minCodeSize=D;let E=-1;const F=++t;for(r("| | Counting total sub-block length");0!==s[t];){const I=s[t];E+=I,t+=I+1}r("| | Processing sub-block");const G=Array(E);let H=-1;for(t=F;0!==s[t];){const I=s[t];for(let J=0;I>J;++J)G[++H]=s[++t];++t}u.frames[v].rawData=G,r(`| | Sub-block processed`),++t,r(`| Frame #${++v} processed`)}break;case 59:r(`GIF processed in ${performance.now()-n} ms`),++t;break loop;default:A="unknown block";break loop;}if(A)throw new TypeError(`${A}\n0x${s[t].toString(16).toUpperCase().padStart(2,0)} @ 0x${t.toString(16).toUpperCase().padStart(8,0)}`);return t!==q&&r(`/!\\ Additional ${q-t} bytes of data after tail ignored`),u}})();(()=>{try{return!!window.document.documentElement}catch(a){return!1}})()||(this.onmessage=a=>{let b=0,c=-1,d,f,g=0,k=0;fetch(a.data,{headers:{pragma:"no-cache","cache-control":"no-cache"}}).then(m=>m.arrayBuffer()).then(GIF).then(async m=>{b=m.frames.length,d=Array(b),f=m.frames.map(s=>s.graphicExtension.delay-1);const q=m.frames.map(s=>s.graphicExtension.disposalMethod);({width:g,height:k}=m.descriptor);for(const r=new ImageData(g,k);++c<b;){const[{data:u,width:v,height:y},s,t]=await m.toImageData(c);switch(q[c]){case 2:for(let A=0;y>A;++A)for(let C,B=0;v>B;++B)C=v*(A+t)+4*(B+s),r.data[C]=0,r.data[++C]=0,r.data[++C]=0,r.data[++C]=0;break;case 3:if(d[0]){const[{data:C,width:D,height:E},A,B]=d[Math.max(c-1,0)];for(let F=0;E>F;++F)for(let H,G=0;D>G;++G)H=D*(F+B)+4*(G+A),r.data[H]=C[H],r.data[++H]=C[H],r.data[++H]=C[H],r.data[++H]=C[H]}}for(let A=0;y>A;++A)for(let C,B=0;v>B;++B)C=v*(A+t)+4*(B+s),0===u[C+3]||(r.data[C]=u[C],r.data[++C]=u[C],r.data[++C]=u[C],r.data[++C]=u[C]);const z=new Uint8ClampedArray(u);d[c]=[new ImageData(z,v,y),s,t]}postMessage([d,f,g,k])})});