const GIF=(()=>{const g=Symbol(),i=Symbol(),l=async function(N,O=!1){if(!(Number.isInteger(N)&&-1<N))throw new TypeError("`index` is not a valid number");if(!this[g])throw new TypeError("`this` is not a GIF object");if(this.frames[N].data)return this.frames[N].data;const{rawData:P,minCodeSize:Q,descriptor:{width:R,height:S}}=this.frames[N],T=R*S,U=Array(T),V=Array(4096),W=Array(4096),X=Array(4097),Y=1<<Q;let Z=Y+2,$=-1,_=Q+1,aa=(1<<_)-1,ba=0;for(;Y>ba;++ba)V[ba]=0,W[ba]=ba;let ca,da=0,ea=0,fa=0,ga=0,ha=0,ia=0;for(let ja=0;T>ja;){if(0==ga){if(_>ea){da+=P[ha]<<ea,ea+=8,++ha;continue}if(ba=da&aa,da>>=_,ea-=_,ba>Z||ba==Y+1)break;if(ba==Y){_=Q+1,aa=(1<<_)-1,Z=Y+2,$=-1;continue}if(-1==$){X[ga]=W[ba],++ga,$=ba,fa=ba;continue}for(ca=ba,ba==Z&&(X[ga]=fa,ba=$,++ga);ba>Y;)X[ga]=W[ba],ba=V[ba],++ga;fa=255&W[ba],X[ga]=fa,++ga,4096>Z&&(V[Z]=$,W[Z]=fa,0==(++Z&aa)&&4096>Z&&(++_,aa+=Z)),$=ca}U[ia]=X[--ga],++ia,++ja}for(let ja=ia;T>ja;++ja)U[ja]=0;return O&&(this.frames[N].rawData=void 0),this.frames[N].data=U},p=async function(N,O=!1){if(!(Number.isInteger(N)&&-1<N))throw new TypeError("`index` is not a valid number");if(!this[g])throw new TypeError("`this` is not a GIF object");const P=this.frames[N];if(0===P.descriptor.packed.interlaceFlag)throw new TypeError("Can't deinterlace a non-interlaced frame");if(this[i])return P.deinterlacedData;P.data||(await this.inflate(N,!0));const{descriptor:{width:R},data:Q,data:{length:S}}=P,T=Array(S),U=[0,4,2,1],V=[8,8,4,2];let W=-1;for(let X=0;4>X;++X)for(let Y=U[X];S/R>Y;Y+=V[X])T.splice(Y*R,R,...Q.slice(++W*R,(W+1)*R));return O?(P.data=T,P.deinterlacedData=null):P.deinterlacedData=T,Object.defineProperty(this,i,{value:!0}),T},M=async function(N){if(!(Number.isInteger(N)&&-1<N))throw new TypeError("`index` is not a valid number");if(!this[g])throw new TypeError("`this` is not a GIF object");const O=this.frames[N];O.data||(await this.inflate(N,!0)),1!==O.descriptor.packed.interlaceFlag||this[i]||(await this.deinterlace(N,!0));const P=O.deinterlacedData||O.data,{width:Q,height:R,left:S,top:T}=O.descriptor,U=Q*R,V=new Uint8ClampedArray(4*U),W=O.descriptor.packed.localColorTableFlag?O.localColorTable:this.globalColorTable,{transparentColorIndex:X}=O.graphicExtension;for(let Y=0,Z=-1;U>Y;++Y){let $=P[Y],_=W[$];V[++Z]=_[0],V[++Z]=_[1],V[++Z]=_[2],V[++Z]=$===X?0:255}return[new ImageData(V,Q,R),S,T]};return async function(N,O=!1){const P=performance.now(),Q=N.byteLength,R=O?console.log:()=>{},S=new Uint8Array(N);let T=5;R("GIF >"),R("| Logical Screen Descriptor");const U=Object.defineProperties({descriptor:{width:S[++T]|S[++T]<<8,height:S[++T]|S[++T]<<8,packed:{globalColorTableFlag:(128&S[++T])>>7,colorResolution:(64&S[T]|32&S[T]|16&S[T])>>4,sortFlag:(8&S[T])>>3,size:4&S[T]|2&S[T]|1&S[T]},backgroundColorIndex:S[++T],pixelAspectRatio:S[++T]},globalColorTable:void 0,repeat:0,frames:[]},{[g]:{value:!0},inflate:{value:l},deinterlace:{value:p},toImageData:{value:M}});if(U.descriptor.packed.globalColorTableFlag){R("| Global Color Table");const Z=2**(U.descriptor.packed.size+1),$=new Uint8Array(N,++T,3*Z),_=Array(Z);for(let aa=0,ba=0;Z>aa;++aa,T+=3)_[aa]=[,,,],ba=-1,_[aa][++ba]=$[3*aa+ba],_[aa][++ba]=$[3*aa+ba],_[aa][++ba]=$[3*aa+ba];U.globalColorTable=_}else++T;let V=0;const W=()=>({graphicExtension:void 0,deinterlacedData:void 0,localColorTable:void 0,minCodeSize:void 0,descriptor:void 0,rawData:void 0,data:void 0}),X=[78,69,84,83,67,65,80,69,50,46,48];let Y;loop:for(;Q>T;)switch(S[T]){case 33:switch(R("| Extension"),S[++T]){case 249:{R("| | Graphics Control");const Z=S[++T];let $=0,_=new Uint8Array(N,++T,Z);if(0!==S[T+=Z]){Y="missing null";break loop}U.frames[V]||(U.frames[V]=W());let aa;U.frames[V].graphicExtension={disposalMethod:(16&_[$]|8&_[$]|4&_[$])>>2,userInputFlag:(2&_[$])>>1,transparentColorFlag:aa=1&_[$],delay:10*(_[++$]|_[++$]<<8),transparentColorIndex:aa?_[++$]:(++$,0)}}break;case 255:{R("| | Application");const Z=S[++T];if(11!==Z){Y="app extension header of 11 byte length expected";break loop}let $=!0;for(let _=0;Z>_&&$;++_)$=X[_]===S[1+_+T];if($){if(1!==S[T+=Z+2]){Y="invalid NETSCAPE block";break loop}if(U.repeat=S[++T]|S[++T]<<8,0!==S[++T]){Y="missing null";break loop}}else{for(;0!==S[++T];);++T}}break;case 254:case 1:for(;0!==S[++T];)T+=S[T];break;default:Y="unknown extension";break loop;}++T;break;case 44:{U.frames[V]||(U.frames[V]=W()),R(`| Image Descriptor #${1+V}`);let Z=0,$=0;if(U.frames[V].descriptor={left:S[++T]|S[++T]<<8,top:S[++T]|S[++T]<<8,width:S[++T]|S[++T]<<8,height:S[++T]|S[++T]<<8,packed:{localColorTableFlag:Z=(128&S[++T])>>7,interlaceFlag:(64&S[T])>>6,sortFlag:(32&S[T])>>5,size:$=4&S[T]|2&S[T]|1&S[T]}},1==Z){R("| Local Color Table");const ea=2**($+1),fa=new Uint8Array(N,++T,3*ea),ga=Array(ea);for(let ha=0,ia=0;ea>ha;++ha,T+=3)ga[ha]=[,,,],ia=-1,ga[ha][++ia]=fa[3*ha+ia],ga[ha][++ia]=fa[3*ha+ia],ga[ha][++ia]=fa[3*ha+ia];U.frames[V].localColorTable=ga,--T}R("| Image Data");const _=S[++T];if(8<_||2>_){Y="invalid LZW minimum code size";break loop}U.frames[V].minCodeSize=_;let aa=-1;const ba=++T;for(R("| | Counting total sub-block length");0!==S[T];){const ea=S[T];aa+=ea,T+=ea+1}R("| | Processing sub-block");const ca=Array(aa);let da=-1;for(T=ba;0!==S[T];){const ea=S[T];for(let fa=0;ea>fa;++fa)ca[++da]=S[++T];++T}U.frames[V].rawData=ca,R(`| | Sub-block processed`),++T,R(`| Frame #${++V} processed`)}break;case 59:R(`GIF processed in ${performance.now()-P} ms`),++T;break loop;default:Y="unknown block";break loop;}if(Y)throw new TypeError(`${Y}\n0x${S[T].toString(16).toUpperCase().padStart(2,0)} @ 0x${T.toString(16).toUpperCase().padStart(8,0)}`);return T!==Q&&R(`/!\\ Additional ${Q-T} bytes of data after tail ignored`),U}})();if (!(() => { try { return Boolean(window.document.documentElement); } catch(e) { return false; } })()) {
  const log = (...msg) => postMessage(["log", ...msg]);
  const messageHandler = async e => {
    let frameCount = 0;
    let index = -1;
    let compiledFrames = void 0;
    let delays = void 0;
    let canvasWidth = 0;
    let canvasHeight = 0;
    try {
      const request = await fetch(e.data, { headers: { pragma: "no-cache", "cache-control": "no-cache" }});
      const o = await GIF(await request.arrayBuffer());
      frameCount = o.frames.length;
      compiledFrames = new Array(frameCount);
      delays = o.frames.map(frameObj =>
        frameObj.graphicExtension.delay - 1
      );
      const disposals = o.frames.map(frameObj =>
        frameObj.graphicExtension.disposalMethod
      );
      ({ width: canvasWidth, height: canvasHeight } = o.descriptor);
      const canvas = new Uint8ClampedArray(canvasWidth * canvasHeight * 4);
      while(++index < frameCount) {
        const { transparentColorFlag } = o.frames[index].graphicExtension;
        const [{ data: frameImageData, width: frameWidth, height: frameHeight }, offsetLeft, offsetTop] = await o.toImageData(index);
        switch(disposals[index]) {
         case 2:
          for (let row = 0, column = 0, offset; offset = (column + offsetLeft + (row + offsetTop) * canvasWidth) * 4, frameHeight > row; column = 0, row += 1)
          for (; frameWidth > column; ++column) {
            canvas[  offset] = 0;
            canvas[++offset] = 0;
            canvas[++offset] = 0;
            canvas[++offset] = transparentColorFlag ? 0 : 255;
          } break;
         case 3:
          if (index > 0) {
            const [{ data: frameImageData, width: frameWidth, height: frameHeight }, offsetLeft, offsetTop] = compiledFrames[index - 1];
            for (let row = 0, column = 0, pointer = -1, offset; offset = (column + offsetLeft + (row + offsetTop) * canvasWidth) * 4, frameHeight > row; column = 0, row += 1)
            for (; frameWidth > column; ++column) {
              canvas[  offset] = frameImageData[++pointer];
              canvas[++offset] = frameImageData[++pointer];
              canvas[++offset] = frameImageData[++pointer];
              canvas[++offset] = frameImageData[++pointer];
            }
          } break;
        }
        for (let row = 0, column = 0, pointer = -1, offset; offset = (column + offsetLeft + (row + offsetTop) * canvasWidth) * 4, frameHeight > row; column = 0, row += 1)
        for (; frameWidth > column; ++column) {
          if (transparentColorFlag && frameImageData[pointer + 4] === 0) { // skip if transparent pixel
            pointer += 4;
            continue;
          }
          canvas[  offset] = frameImageData[++pointer];
          canvas[++offset] = frameImageData[++pointer];
          canvas[++offset] = frameImageData[++pointer]; ++pointer;
          canvas[++offset] = transparentColorFlag ? frameImageData[pointer] : 255;
        }
        for (let row = 0, column = 0, pointer = -1, offset; offset = (column + offsetLeft + (row + offsetTop) * canvasWidth) * 4, frameHeight > row; column = 0, row += 1)
        for (; frameWidth > column; ++column) {
          frameImageData[++pointer] = canvas[  offset];
          frameImageData[++pointer] = canvas[++offset];
          frameImageData[++pointer] = canvas[++offset];
          frameImageData[++pointer] = canvas[++offset];
        }
        compiledFrames[index] = [new ImageData(frameImageData, frameWidth, frameHeight), offsetLeft, offsetTop];
      }
      postMessage([compiledFrames, delays, canvasWidth, canvasHeight]);
    } catch(e) {
      log(e);
    }
  }
  this.onmessage = messageHandler;
}