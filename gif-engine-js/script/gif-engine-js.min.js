const GIF=(()=>{const g=Symbol(),i=Symbol(),l=async function(N,O=!1){if(!(Number.isInteger(N)&&-1<N))throw new TypeError("`index` is not a valid number");if(!this[g])throw new TypeError("`this` is not a GIF object");if(this.frames[N].data)return this.frames[N].data;const{rawData:P,minCodeSize:Q,descriptor:{width:R,height:S}}=this.frames[N],T=R*S,U=Array(T),V=Array(4096),W=Array(4096),X=Array(4097),Y=1<<Q;let Z=Y+2,$=-1,_=Q+1,aa=(1<<_)-1,ba=0;for(;Y>ba;++ba)V[ba]=0,W[ba]=ba;let ca,da=0,ea=0,fa=0,ga=0,ha=0,ia=0;for(let ja=0;T>ja;){if(0==ga){if(_>ea){da+=P[ha]<<ea,ea+=8,++ha;continue}if(ba=da&aa,da>>=_,ea-=_,ba>Z||ba==Y+1)break;if(ba==Y){_=Q+1,aa=(1<<_)-1,Z=Y+2,$=-1;continue}if(-1==$){X[ga]=W[ba],++ga,$=ba,fa=ba;continue}for(ca=ba,ba==Z&&(X[ga]=fa,ba=$,++ga);ba>Y;)X[ga]=W[ba],ba=V[ba],++ga;fa=255&W[ba],X[ga]=fa,++ga,4096>Z&&(V[Z]=$,W[Z]=fa,0==(++Z&aa)&&4096>Z&&(++_,aa+=Z)),$=ca}U[ia]=X[--ga],++ia,++ja}for(let ja=ia;T>ja;++ja)U[ja]=0;return O&&(this.frames[N].rawData=void 0),this.frames[N].data=U},p=async function(N,O=!1){if(!(Number.isInteger(N)&&-1<N))throw new TypeError("`index` is not a valid number");if(!this[g])throw new TypeError("`this` is not a GIF object");const P=this.frames[N];if(0===P.descriptor.packed.interlaceFlag)throw new TypeError("Can't deinterlace a non-interlaced frame");if(this[i])return P.deinterlacedData;P.data||(await this.inflate(N,!0));const{descriptor:{width:R},data:Q,data:{length:S}}=P,T=Array(S),U=[0,4,2,1],V=[8,8,4,2];let W=-1;for(let X=0;4>X;++X)for(let Y=U[X];S/R>Y;Y+=V[X])T.splice(Y*R,R,...Q.slice(++W*R,(W+1)*R));return O?(P.data=T,P.deinterlacedData=null):P.deinterlacedData=T,Object.defineProperty(this,i,{value:!0}),T},M=async function(N){if(!(Number.isInteger(N)&&-1<N))throw new TypeError("`index` is not a valid number");if(!this[g])throw new TypeError("`this` is not a GIF object");const O=this.frames[N];O.data||(await this.inflate(N,!0)),1!==O.descriptor.packed.interlaceFlag||this[i]||(await this.deinterlace(N,!0));const P=O.deinterlacedData||O.data,{width:Q,height:R,left:S,top:T}=O.descriptor,U=Q*R,V=new Uint8ClampedArray(4*U),W=O.descriptor.packed.localColorTableFlag?O.localColorTable:this.globalColorTable,{transparentColorIndex:X}=O.graphicExtension;for(let Y=0,Z=-1;U>Y;++Y){let $=P[Y],_=W[$];V[++Z]=_[0],V[++Z]=_[1],V[++Z]=_[2],V[++Z]=$===X?0:255}return[new ImageData(V,Q,R),S,T]};return async function(N,O=!1){const P=performance.now(),Q=N.byteLength,R=O?console.log:()=>{},S=new Uint8Array(N);let T=5;R("GIF >"),R("| Logical Screen Descriptor");const U=Object.defineProperties({descriptor:{width:S[++T]|S[++T]<<8,height:S[++T]|S[++T]<<8,packed:{globalColorTableFlag:(128&S[++T])>>7,colorResolution:(64&S[T]|32&S[T]|16&S[T])>>4,sortFlag:(8&S[T])>>3,size:4&S[T]|2&S[T]|1&S[T]},backgroundColorIndex:S[++T],pixelAspectRatio:S[++T]},globalColorTable:void 0,repeat:0,frames:[]},{[g]:{value:!0},inflate:{value:l},deinterlace:{value:p},toImageData:{value:M}});if(U.descriptor.packed.globalColorTableFlag){R("| Global Color Table");const Z=2**(U.descriptor.packed.size+1),$=new Uint8Array(N,++T,3*Z),_=Array(Z);for(let aa=0,ba=0;Z>aa;++aa,T+=3)_[aa]=[,,,],ba=-1,_[aa][++ba]=$[3*aa+ba],_[aa][++ba]=$[3*aa+ba],_[aa][++ba]=$[3*aa+ba];U.globalColorTable=_}else++T;let V=0;const W=()=>({graphicExtension:void 0,deinterlacedData:void 0,localColorTable:void 0,minCodeSize:void 0,descriptor:void 0,rawData:void 0,data:void 0}),X=[78,69,84,83,67,65,80,69,50,46,48];let Y;loop:for(;Q>T;)switch(S[T]){case 33:switch(R("| Extension"),S[++T]){case 249:{R("| | Graphics Control");const Z=S[++T];let $=0,_=new Uint8Array(N,++T,Z);if(0!==S[T+=Z]){Y="missing null";break loop}U.frames[V]||(U.frames[V]=W());let aa;U.frames[V].graphicExtension={disposalMethod:(16&_[$]|8&_[$]|4&_[$])>>2,userInputFlag:(2&_[$])>>1,transparentColorFlag:aa=1&_[$],delay:10*(_[++$]|_[++$]<<8),transparentColorIndex:aa?_[++$]:(++$,0)}}break;case 255:{R("| | Application");const Z=S[++T];if(11!==Z){Y="app extension header of 11 byte length expected";break loop}let $=!0;for(let _=0;Z>_&&$;++_)$=X[_]===S[1+_+T];if($){if(1!==S[T+=Z+2]){Y="invalid NETSCAPE block";break loop}if(U.repeat=S[++T]|S[++T]<<8,0!==S[++T]){Y="missing null";break loop}}else{for(;0!==S[++T];);++T}}break;case 254:case 1:for(;0!==S[++T];)T+=S[T];break;default:Y="unknown extension";break loop;}++T;break;case 44:{U.frames[V]||(U.frames[V]=W()),R(`| Image Descriptor #${1+V}`);let Z=0,$=0;if(U.frames[V].descriptor={left:S[++T]|S[++T]<<8,top:S[++T]|S[++T]<<8,width:S[++T]|S[++T]<<8,height:S[++T]|S[++T]<<8,packed:{localColorTableFlag:Z=(128&S[++T])>>7,interlaceFlag:(64&S[T])>>6,sortFlag:(32&S[T])>>5,size:$=4&S[T]|2&S[T]|1&S[T]}},1==Z){R("| Local Color Table");const ea=2**($+1),fa=new Uint8Array(N,++T,3*ea),ga=Array(ea);for(let ha=0,ia=0;ea>ha;++ha,T+=3)ga[ha]=[,,,],ia=-1,ga[ha][++ia]=fa[3*ha+ia],ga[ha][++ia]=fa[3*ha+ia],ga[ha][++ia]=fa[3*ha+ia];U.frames[V].localColorTable=ga,--T}R("| Image Data");const _=S[++T];if(8<_||2>_){Y="invalid LZW minimum code size";break loop}U.frames[V].minCodeSize=_;let aa=-1;const ba=++T;for(R("| | Counting total sub-block length");0!==S[T];){const ea=S[T];aa+=ea,T+=ea+1}R("| | Processing sub-block");const ca=Array(aa);let da=-1;for(T=ba;0!==S[T];){const ea=S[T];for(let fa=0;ea>fa;++fa)ca[++da]=S[++T];++T}U.frames[V].rawData=ca,R(`| | Sub-block processed`),++T,R(`| Frame #${++V} processed`)}break;case 59:R(`GIF processed in ${performance.now()-P} ms`),++T;break loop;default:Y="unknown block";break loop;}if(Y)throw new TypeError(`${Y}\n0x${S[T].toString(16).toUpperCase().padStart(2,0)} @ 0x${T.toString(16).toUpperCase().padStart(8,0)}`);return T!==Q&&R(`/!\\ Additional ${Q-T} bytes of data after tail ignored`),U}})();if(!(()=>{try{return!!window.document.documentElement}catch(a){return!1}})()){const a=(...c)=>postMessage(["log",...c]);this.onmessage=async c=>{let d=0,f=-1,g,h,i=0,j=0;try{const k=await fetch(c.data,{headers:{pragma:"no-cache","cache-control":"no-cache"}}),l=await GIF((await k.arrayBuffer()));d=l.frames.length,g=Array(d),h=l.frames.map(p=>p.graphicExtension.delay-1);const m=l.frames.map(p=>p.graphicExtension.disposalMethod);({width:i,height:j}=l.descriptor);for(const n=new Uint8ClampedArray(4*(i*j));++f<d;){const{transparentColorFlag:p}=l.frames[f].graphicExtension;const[{data:s,width:t,height:u},q,r]=await l.toImageData(f);switch(m[f]){case 2:for(let v=0;u>v;++v)for(let x,w=0;t>w;++w)x=4*(w+q+(v+r)*i),n[x]=0,n[++x]=0,n[++x]=0,n[++x]=p?0:255;break;case 3:if(0<f){const[{data:x,width:y,height:z},v,w]=g[f-1];for(let A=0,B=-1;z>A;++A)for(let D,C=0;y>C;++C)D=4*(C+v+(A+w)*i),n[D]=x[++B],n[++D]=x[++B],n[++D]=x[++B],n[++D]=x[++B]}}for(let v=0,w=-1;u>v;++v)for(let y,x=0;t>x;++x){if(y=4*(x+q+(v+r)*i),p&&0===s[w+4]){w+=4;continue}n[y]=s[++w],n[++y]=s[++w],n[++y]=s[++w],++w,n[++y]=p?s[w]:255}for(let v=0,w=-1;u>v;++v)for(let y,x=0;t>x;++x)y=4*(x+q+(v+r)*i),s[++w]=n[y],s[++w]=n[++y],s[++w]=n[++y],s[++w]=n[++y];g[f]=[new ImageData(s,t,u),q,r]}postMessage([g,h,i,j])}catch(k){a(k)}}}