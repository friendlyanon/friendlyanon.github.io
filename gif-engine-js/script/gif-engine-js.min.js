const GIF=(()=>{const a=Symbol(),b=Symbol(),c=async function(g,h=!1){if(!(Number.isInteger(g)&&-1<g))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");if(this.frames[g].data)return this.frames[g].data;const{rawData:j,minCodeSize:k,descriptor:{width:m,height:n}}=this.frames[g],o=m*n,q=Array(o),r=Array(4096),s=Array(4096),t=Array(4097),u=1<<k;let w=u+2,x=-1,y=k+1,z=(1<<y)-1,A=0;for(;u>A;++A)r[A]=0,s[A]=A;let H,B=0,C=0,D=0,E=0,F=0,G=0;for(let I=0;o>I;){if(0==E){if(y>C){B+=j[F]<<C,C+=8,++F;continue}if(A=B&z,B>>=y,C-=y,A>w||A===u+1)break;if(A==u){y=k+1,z=(1<<y)-1,w=u+2,x=-1;continue}if(-1==x){t[E]=s[A],++E,x=A,D=A;continue}for(H=A,A==w&&(t[E]=D,A=x,++E);A>u;)t[E]=s[A],A=r[A],++E;D=255&s[A],t[E]=D,++E,4096>w&&(r[w]=x,s[w]=D,0==(++w&z)&&4096>w&&(++y,z+=w)),x=H}q[G]=t[--E],++G,++I}for(let I=G;o>I;++I)q[I]=0;return h&&(this.frames[g].rawData=void 0),this.frames[g].data=q},d=async function(g,h=!1){if(!(Number.isInteger(g)&&-1<g))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");const j=this.frames[g];if(0===j.descriptor.packed.interlaceFlag)throw new TypeError("Can't deinterlace a non-interlaced frame");if(this[b])return j.deinterlacedData;j.data||(await this.inflate(g,!0));const{descriptor:{width:m},data:k,data:{length:n}}=j,q=Array(n),r=[0,4,2,1],s=[8,8,4,2];let t=-1;for(let u=0;4>u;++u)for(let v=r[u];n/m>v;v+=s[u])q.splice(v*m,m,...k.slice(++t*m,(t+1)*m));return h?(j.data=q,j.deinterlacedData=null):j.deinterlacedData=q,Object.defineProperty(this,b,{value:!0}),q},e=async function(g){if(!(Number.isInteger(g)&&-1<g))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");const h=this.frames[g];h.data||(await this.inflate(g,!0)),1!==h.descriptor.packed.interlaceFlag||this[b]||(await this.deinterlace(g,!0));const j=h.deinterlacedData||h.data,{width:k,height:m,left:n,top:o}=h.descriptor,q=k*m,r=new Uint8ClampedArray(4*q),s=h.descriptor.packed.localColorTableFlag?h.localColorTable:this.globalColorTable,{transparentColorIndex:t}=h.graphicExtension;for(let u=0,v=-1;q>u;++u){let w=j[u],x=s[w];r[++v]=x[0],r[++v]=x[1],r[++v]=x[2],r[++v]=w===t?0:255}return[new ImageData(r,k,m),n,o]};return async function(g,h=!1){const j=performance.now(),k=g.byteLength,m=h?console.log:()=>{},n=new Uint8Array(g);let o=5;m("GIF >"),m("| Logical Screen Descriptor");const q=Object.defineProperties({descriptor:{width:n[++o]|n[++o]<<8,height:n[++o]|n[++o]<<8,packed:{globalColorTableFlag:(128&n[++o])>>7,colorResolution:(64&n[o]|32&n[o]|16&n[o])>>4,sortFlag:(8&n[o])>>3,size:4&n[o]|2&n[o]|1&n[o]},backgroundColorIndex:n[++o],pixelAspectRatio:n[++o]},globalColorTable:void 0,repeat:0,frames:[]},{[a]:{value:!0},inflate:{value:c},deinterlace:{value:d},toImageData:{value:e},drawFrameToCanvas:{value:drawFrameToCanvas}});if(q.descriptor.packed.globalColorTableFlag){m("| Global Color Table");const v=2**(q.descriptor.packed.size+1),w=new Uint8Array(g,++o,3*v),x=Array(v);for(let y=0,z=0;v>y;++y,o+=3)x[y]=[,,,],z=-1,x[y][++z]=w[3*y+z],x[y][++z]=w[3*y+z],x[y][++z]=w[3*y+z];q.globalColorTable=x}else++o;let r=0;const s=()=>({graphicExtension:void 0,deinterlacedData:void 0,localColorTable:void 0,minCodeSize:void 0,descriptor:void 0,rawData:void 0,data:void 0}),t=[78,69,84,83,67,65,80,69,50,46,48];let u;loop:for(;k>o;)switch(n[o]){case 33:switch(m("| Extension"),n[++o]){case 249:{m("| | Graphics Control");const v=n[++o];let w=0,x=new Uint8Array(g,++o,v);if(0!==n[o+=v]){u="missing null";break loop}q.frames[r]||(q.frames[r]=s());let y;q.frames[r].graphicExtension={disposalMethod:(16&x[w]|8&x[w]|4&x[w])>>2,userInputFlag:(2&x[w])>>1,transparentColorFlag:y=1&x[w],delay:10*(x[++w]|x[++w]<<8),transparentColorIndex:y?x[++w]:(++w,0)}}break;case 255:{m("| | Application");const v=n[++o];if(11!==v){u="app extension header of 11 byte length expected";break loop}let w=!0;for(let x=0;v>x&&w;++x)w=t[x]===n[1+x+o];if(w){if(1!==n[o+=v+2]){u="invalid NETSCAPE block";break loop}if(q.repeat=n[++o]|n[++o]<<8,0!==n[++o]){u="missing null";break loop}}else{for(;0!==n[++o];);++o}}break;case 254:case 1:for(;0!==n[++o];)o+=n[o];break;default:u="unknown extension";break loop;}++o;break;case 44:{q.frames[r]||(q.frames[r]=s()),m(`| Image Descriptor #${1+r}`);let v=0,w=0;if(q.frames[r].descriptor={left:n[++o]|n[++o]<<8,top:n[++o]|n[++o]<<8,width:n[++o]|n[++o]<<8,height:n[++o]|n[++o]<<8,packed:{localColorTableFlag:v=(128&n[++o])>>7,interlaceFlag:(64&n[o])>>6,sortFlag:(32&n[o])>>5,size:w=4&n[o]|2&n[o]|1&n[o]}},1==v){m("| Local Color Table");const C=2**(w+1),D=new Uint8Array(g,++o,3*C),E=Array(C);for(let F=0,G=0;C>F;++F,o+=3)E[F]=[,,,],G=-1,E[F][++G]=D[3*F+G],E[F][++G]=D[3*F+G],E[F][++G]=D[3*F+G];q.frames[r].localColorTable=E,--o}m("| Image Data");const x=n[++o];if(8<x||2>x){u="invalid LZW minimum code size";break loop}q.frames[r].minCodeSize=x;let y=-1;const z=++o;for(m("| | Counting total sub-block length");0!==n[o];){const C=n[o];y+=C,o+=C+1}m("| | Processing sub-block");const A=Array(y);let B=-1;for(o=z;0!==n[o];){const C=n[o];for(let D=0;C>D;++D)A[++B]=n[++o];++o}q.frames[r].rawData=A,m(`| | Sub-block processed`),++o,m(`| Frame #${++r} processed`)}break;case 59:m(`GIF processed in ${performance.now()-j} ms`),++o;break loop;default:u="unknown block";break loop;}if(u)throw new TypeError(`${u}\n0x${n[o].toString(16).toUpperCase().padStart(2,0)} @ 0x${o.toString(16).toUpperCase().padStart(8,0)}`);return o!==k&&m(`/!\\ Additional ${k-o} bytes of data after tail ignored`),q}})();