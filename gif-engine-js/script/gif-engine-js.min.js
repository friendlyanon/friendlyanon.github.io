const GIF=(()=>{const a=Symbol(),b=Symbol(),c=async function(s,t=!1){if(!(Number.isInteger(s)&&-1<s))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");const u=this.frames[s];if(u.data)return u.data;const{rawData:v,minCodeSize:w,descriptor:{width:x,height:y}}=u,z=x*y,A=Array(z),B=Array(4096),C=Array(4096),D=Array(4097),E=1<<w;let G=E+2,H=-1,I=w+1,J=(1<<I)-1,K=0;for(;E>K;++K)B[K]=0,C[K]=K;let R,L=0,M=0,N=0,O=0,P=0,Q=0;for(let S=0;z>S;){if(0==O){if(I>M){L+=v[P]<<M,M+=8,++P;continue}if(K=L&J,L>>=I,M-=I,K>G||K===E+1)break;if(K==E){I=w+1,J=(1<<I)-1,G=E+2,H=-1;continue}if(-1==H){D[O]=C[K],++O,H=K,N=K;continue}for(R=K,K==G&&(D[O]=N,K=H,++O);K>E;)D[O]=C[K],K=B[K],++O;N=255&C[K],D[O]=N,++O,4096>G&&(B[G]=H,C[G]=N,0==(++G&J)&&4096>G&&(++I,J+=G)),H=R}A[Q]=D[--O],++Q,++S}for(let S=Q;z>S;++S)A[S]=0;return t&&(u.rawData=void 0),u.data=A},d=async function(s,t=!1){if(!(Number.isInteger(s)&&-1<s))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");const u=this.frames[s];if(!u.descriptor.packed.interlaceFlag)throw new TypeError("Can't deinterlace a non-interlaced frame");if(this[b])return u.deinterlacedData;u.data||(await this.inflate(s,!0));const{descriptor:{width:w},data:v,data:{length:x}}=u,z=Array(x),A=[0,4,2,1],B=[8,8,4,2];let C=-1;for(let D=0;4>D;++D)for(let E=A[D];x/w>E;E+=B[D])z.splice(E*w,w,...v.slice(++C*w,(C+1)*w));return t?(u.data=z,u.deinterlacedData=null):u.deinterlacedData=z,Object.defineProperty(this,b,{value:!0}),z},f=Array(256).fill(0),g=async function(s){if(!(Number.isInteger(s)&&-1<s))throw new TypeError("`index` is not a valid number");if(!this[a])throw new TypeError("`this` is not a GIF object");const t=this.frames[s];t.data||(await this.inflate(s,!0));const{interlaceFlag:u,localColorTableFlag:v}=t.descriptor.packed;u&&!this[b]&&(await this.deinterlace(s,!0));const w=t.deinterlacedData||t.data,{width:x,height:y,left:z,top:A}=t.descriptor,B=x*y,C=new Uint8ClampedArray(4*B),D=(v?t.localColorTable:this.globalColorTable)||f,E=t.graphicExtension&&t.graphicExtension.transparentColorIndex||0;for(let F=0,G=-1;B>F;++F){let H=w[F],I=D[H];C[++G]=I[0],C[++G]=I[1],C[++G]=I[2],C[++G]=H===E?0:255}return[new ImageData(C,x,y),z,A]},h=()=>({graphicExtension:void 0,deinterlacedData:void 0,localColorTable:void 0,minCodeSize:void 0,descriptor:void 0,rawData:void 0,data:void 0}),j=performance&&"function"==typeof performance.now?()=>performance.now():()=>Date.now(),k=console.log,m=()=>{},n=[71,73,70,56,57,97],q=[78,69,84,83,67,65,80,69,50,46,48];return async function(s,t=!1){if(!(s instanceof ArrayBuffer))throw new TypeError("Source isn't an ArrayBuffer");const u=j(),v=s.byteLength,w=t?k:m;w("GIF >");const x=new Uint8Array(s);let y=!0,z=-1;for(let D=0;6>D&&y;++D)y=n[D]===x[++z];if(!y)throw new TypeError("Source is not a GIF89a");w("| Logical Screen Descriptor");const A=Object.defineProperties({descriptor:{width:x[++z]|x[++z]<<8,height:x[++z]|x[++z]<<8,packed:{globalColorTableFlag:(128&x[++z])>>7,colorResolution:(64&x[z]|32&x[z]|16&x[z])>>4,sortFlag:(8&x[z])>>3,size:4&x[z]|2&x[z]|1&x[z]},backgroundColorIndex:x[++z],pixelAspectRatio:x[++z]},globalColorTable:void 0,repeat:0,frames:[]},{[a]:{value:!0},inflate:{value:c},deinterlace:{value:d},toImageData:{value:g}});if(A.descriptor.packed.globalColorTableFlag){w("| Global Color Table");const D=2**(A.descriptor.packed.size+1),E=new Uint8Array(s,++z,3*D),F=Array(D);for(let G=0,H=0;D>G;++G,z+=3){const I=F[G]=[,,,];H=-1,I[++H]=E[3*G+H],I[++H]=E[3*G+H],I[++H]=E[3*G+H]}A.globalColorTable=F}else++z;let C,B=0;loop:for(;v>z;)switch(x[z]){case 33:switch(w("| Extension"),x[++z]){case 249:{w("| | Graphics Control");const D=x[++z];let E=0,F=new Uint8Array(s,++z,D);if(0!==x[z+=D]){C="missing null";break loop}A.frames[B]||(A.frames[B]=h());let G;A.frames[B].graphicExtension={disposalMethod:(16&F[E]|8&F[E]|4&F[E])>>2,userInputFlag:(2&F[E])>>1,transparentColorFlag:G=1&F[E],delay:10*(F[++E]|F[++E]<<8),transparentColorIndex:G?F[++E]:(++E,0)}}break;case 255:{w("| | Application");const D=x[++z];if(11!==D){C="app extension header of 11 byte length expected";break loop}let E=!0;for(let F=0;D>F&&E;++F)E=q[F]===x[1+F+z];if(E){if(1!==x[z+=D+2]){C="invalid NETSCAPE block";break loop}if(A.repeat=x[++z]|x[++z]<<8,0!==x[++z]){C="missing null";break loop}}else{for(;0!==x[++z];);++z}}break;case 254:case 1:for(;0!==x[++z];)z+=x[z];break;default:C="unknown extension";break loop;}++z;break;case 44:{A.frames[B]||(A.frames[B]=h());const D=A.frames[B];w(`| Image Descriptor #${1+B}`);let E,F=0;if(D.descriptor={left:x[++z]|x[++z]<<8,top:x[++z]|x[++z]<<8,width:x[++z]|x[++z]<<8,height:x[++z]|x[++z]<<8,packed:{localColorTableFlag:E=(128&x[++z])>>7,interlaceFlag:(64&x[z])>>6,sortFlag:(32&x[z])>>5,size:F=4&x[z]|2&x[z]|1&x[z]}},E){w("| Local Color Table");const L=2**(F+1),M=new Uint8Array(s,++z,3*L),N=Array(L);for(let O=0,P=0;L>O;++O,z+=3){const Q=N[O]=[,,,];P=-1,Q[++P]=M[3*O+P],Q[++P]=M[3*O+P],Q[++P]=M[3*O+P]}D.localColorTable=N,--z}w("| Image Data");const G=x[++z];if(8<G||2>G){C="invalid LZW minimum code size";break loop}D.minCodeSize=G;let H=-1;const I=++z;for(w("| | Counting total sub-block length");0!==x[z];){const L=x[z];H+=L,z+=L+1}1>H&&(H=1),w("| | Processing sub-block");const J=Array(H);let K=-1;for(z=I;0!==x[z];){const L=x[z];for(let M=0;L>M;++M)J[++K]=x[++z];++z}D.rawData=J,w(`| | Sub-block processed`),++z,w(`| Frame #${++B} processed`)}break;case 59:w(`GIF processed in ${j()-u} ms`),++z;break loop;default:C="unknown block";break loop;}if(C)throw new TypeError(C+`0x${x[z].toString(16).toUpperCase().padStart(2,0)} @ `+`0x${z.toString(16).toUpperCase().padStart(8,0)}`);return z!==v&&w(`/!\\ Additional ${v-z} bytes of data after tail ignored`),A}})(),getDisposals=a=>a.graphicExtension&&a.graphicExtension.disposalMethod||0,getDelays=a=>a.graphicExtension&&a.graphicExtension.delay-1||0,copyColorsTransparent=async(a,b,c,d,f,g,h,j)=>{for(let k=0,m=-1;d>k;++k)for(let q,n=0;c>n;++n){if(q=4*(n+f+(k+g)*h),j&&0===a[m+4]){m+=4;continue}b[q]=a[++m],b[++q]=a[++m],b[++q]=a[++m],++m,b[++q]=j?a[m]:255}},copyColors=async(a,b,c,d,f,g,h)=>{for(let j=0,k=-1;d>j;++j)for(let n,m=0;c>m;++m)n=4*(m+f+(j+g)*h),b[++k]=a[n],b[++k]=a[++n],b[++k]=a[++n],b[++k]=a[++n]},messageHandler=async a=>{const b=await GIF((await(await fetch(a.data,{headers:{pragma:"no-cache","cache-control":"no-cache"}})).arrayBuffer())),c=b.frames.length,d=Array(c),f=b.frames.map(getDelays),g=b.descriptor.width,h=b.descriptor.height,j=b.frames.map(getDisposals),k=new Uint8ClampedArray(4*(g*h));let m=0;do{const n=b.frames[m],q=n.graphicExtension&&n.graphicExtension.transparentColorFlag,[{data:t,width:u,height:v},r,s]=await b.toImageData(m);switch(j[m]){case 2:for(let w=0;v>w;++w)for(let y,x=0;u>x;++x)y=4*(x+r+(w+s)*g),k[y]=0,k[++y]=0,k[++y]=0,k[++y]=q?0:255;break;case 3:if(0<m){const[{data:y,width:z,height:A},w,x]=d[m-1];await copyColors(y,k,z,A,w,x,g)}}await copyColorsTransparent(t,k,u,v,r,s,g,q),await copyColors(k,t,u,v,r,s,g),d[m]=[new ImageData(t,u,v),r,s]}while(++m<c);postMessage([d,f,g,h])};(a=>{a.onmessage=messageHandler,a.onerror=b=>{postMessage(["log",b])}})((()=>this)());
