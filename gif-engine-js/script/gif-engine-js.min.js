"use strict";
const GIF = (() => {
  const GifObjSymbol = Symbol();
  const GifObjInterlaceSymbol = Symbol();
  const LZW = async function(index, clearRawData = false) {
    if (!(Number.isInteger(index) && index > -1))
      throw new TypeError("`index` is not a valid number");
    if (!this[GifObjSymbol])
      throw new TypeError("`this` is not a GIF object");
    const frameObj = this.frames[index];
    if (frameObj.data)
      return frameObj.data;
    const {
      rawData: data,
      minCodeSize: size,
      descriptor: {
        width,
        height
      }
    } = frameObj;
    const pixelCount = width * height;
    const pixels = new Array(pixelCount);
    const prefix = new Array(4096);
    const suffix = new Array(4096);
    const pixelStack = new Array(4097);
    const clear = 1 << size;
    const eoi = clear + 1;
    let available = clear + 2;
    let oldCode = -1;
    let codeSize = size + 1;
    let codeMask = (1 << codeSize) - 1;
    let code = 0;
    for (; clear > code; ++code)
      prefix[code] = 0, suffix[code] = code;
    let datum = 0;
    let bits = 0;
    let first = 0;
    let top = 0;
    let bi = 0;
    let pi = 0;
    let inCode;
    for (let i = 0; pixelCount > i;) {
      if (top === 0) {
        if (codeSize > bits) {	
          datum += data[bi] << bits;
          bits += 8;
          ++bi;
          continue;
        }
        code = datum & codeMask;
        datum >>= codeSize;
        bits -= codeSize;
        if ((code > available) || (code === eoi))
          break;
        if (code === clear) {
          codeSize = size + 1;
          codeMask = (1 << codeSize) - 1;
          available = clear + 2;
          oldCode = -1;
          continue;
        }
        if (oldCode === -1) {
          pixelStack[top] = suffix[code];
          ++top;
          oldCode = code;
          first = code;
          continue;
        }
        inCode = code;
        if (code === available) {
          pixelStack[top] = first;
          code = oldCode;
          ++top;
        }
        while (code > clear) {
          pixelStack[top] = suffix[code];
          code = prefix[code];
          ++top;
        }
        first = suffix[code] & 0xFF;
        pixelStack[top] = first;
        ++top;
        if (4096 > available) {
          prefix[available] = oldCode;
          suffix[available] = first;
          if (((++available & codeMask) === 0) && (4096 > available)) {
            ++codeSize;
            codeMask += available;
          }
        }
        oldCode = inCode;
      }
      pixels[pi] = pixelStack[--top];
      ++pi;
      ++i;
    }
    for (let i = pi; pixelCount > i; ++i)
      pixels[i] = 0;
    if (clearRawData)
      frameObj.rawData = undefined;
    return (frameObj.data = pixels);
  };
  const deinterlace = async function(index, overwriteData = false) {
    if (!(Number.isInteger(index) && index > -1))
      throw new TypeError("`index` is not a valid number");
    if (!this[GifObjSymbol])
      throw new TypeError("`this` is not a GIF object");
    const frameObj = this.frames[index];
    if (!frameObj.descriptor.packed.interlaceFlag)
      throw new TypeError("Can't deinterlace a non-interlaced frame");
    if (this[GifObjInterlaceSymbol])
      return frameObj.deinterlacedData;
    if (!frameObj.data)
      await this.inflate(index, true);
    const {
      descriptor: { width },
      data,
      data: {
        length: l
      }
    } = frameObj;
    const rows = l / width;
    const newPixels = new Array(l);
    const offsets = [0, 4, 2, 1];
    const steps = [8, 8, 4, 2];
    let fromRow = -1;
    for (let pass = 0; 4 > pass; ++pass)
      for (let toRow = offsets[pass]; rows > toRow; toRow += steps[pass])
        newPixels.splice(
          toRow * width,
          width,
          ...data.slice(++fromRow * width, (fromRow + 1) * width)
        );
    if (overwriteData) {
      frameObj.data = newPixels;
      frameObj.deinterlacedData = null;
    }
    else
      frameObj.deinterlacedData = newPixels;
    Object.defineProperty(this, GifObjInterlaceSymbol, { value: true });
    return newPixels;
  };
  const defaultColorTable = new Array(256).fill(0);
  const toImageData = async function(index) {
    if (!(Number.isInteger(index) && index > -1))
      throw new TypeError("`index` is not a valid number");
    if (!this[GifObjSymbol])
      throw new TypeError("`this` is not a GIF object");
    const frameObj = this.frames[index];
    if (!frameObj.data)
      await this.inflate(index, true);
    const {
      interlaceFlag,
      localColorTableFlag
    } = frameObj.descriptor.packed;
    if (interlaceFlag && !this[GifObjInterlaceSymbol])
      await this.deinterlace(index, true);
    const data = frameObj.deinterlacedData || frameObj.data;
    const { width, height, left, top } = frameObj.descriptor;
    const length = width * height;
    const imageData = new Uint8ClampedArray(4 * length);
    const colorTable = (localColorTableFlag ?
      frameObj.localColorTable :
      this.globalColorTable) || defaultColorTable;
    const transparentColorIndex = (frameObj.graphicExtension &&
      frameObj.graphicExtension.transparentColorIndex) || 0;
    for (let i = 0, p = -1; length > i; ++i) {
      let code = data[i], color = colorTable[code];
      imageData[++p] = color[0];
      imageData[++p] = color[1];
      imageData[++p] = color[2];
      imageData[++p] = code === transparentColorIndex ? 0 : 255;
    }
    return [new ImageData(imageData, width, height), left, top];
  };
  const frameObjFactory = () => ({
    graphicExtension: undefined,
    deinterlacedData: undefined,
    localColorTable: undefined,
    minCodeSize: undefined,
    descriptor: undefined,
    rawData: undefined,
    data: undefined
  });
  const timer = performance && typeof performance.now === "function" ?
    () => performance.now() :
    () => Date.now();
  const nativeLog = console.log;
  const noop = () => {};
  const GifMagic = [0x47, 0x49, 0x46, 0x38, 0x39, 0x61];
  const NETSCAPE = [0x4E, 0x45, 0x54,
    0x53, 0x43, 0x41, 0x50, 0x45, 0x32, 0x2E, 0x30];
  const parser = async function(source, verbose = false) {
    if (!(source instanceof ArrayBuffer))
      throw new TypeError("Source isn't an ArrayBuffer");
    const start = timer();
    const length = source.byteLength;
    const log = verbose ? nativeLog : noop;
    log("GIF >");
    const buf = new Uint8Array(source);
    let isGif = true;
    let pos = -1;
    for (let i = 0; 6 > i && isGif; ++i)
      isGif = GifMagic[i] === buf[++pos];
    if (!isGif)
      throw new TypeError("Source is not a GIF89a");
    log("| Logical Screen Descriptor");
    const gif = Object.defineProperties({
      descriptor: {
        width: buf[++pos] | (buf[++pos] << 8),
        height: buf[++pos] | (buf[++pos] << 8),
        packed: {
          globalColorTableFlag: (buf[++pos] & 128) >> 7,
          colorResolution:
            ( (buf[pos] & 64) | (buf[pos] & 32) | (buf[pos] & 16) ) >> 4,
          sortFlag: (buf[pos] & 8) >> 3,
          size: (buf[pos] & 4) | (buf[pos] & 2) | (buf[pos] & 1)
        },
        backgroundColorIndex: buf[++pos],
        pixelAspectRatio: buf[++pos] },
      globalColorTable: undefined,
      repeat: 0,
      frames: []
    }, {
      [GifObjSymbol]: { value: true },
      inflate: { value: LZW },
      deinterlace: { value: deinterlace },
      toImageData: { value: toImageData }
    });
    if (gif.descriptor.packed.globalColorTableFlag) {
      log("| Global Color Table");
      const colors = 2 ** (gif.descriptor.packed.size + 1);
      const gctView = new Uint8Array(source, ++pos, colors * 3);
      const table = new Array(colors);
      for (let i = 0, p = 0; colors > i; ++i, pos += 3) {
        const color = table[i] = new Array(3);
        p = -1;
        color[++p] = gctView[i * 3 + p];
        color[++p] = gctView[i * 3 + p];
        color[++p] = gctView[i * 3 + p];
      }
      gif.globalColorTable = table;
    }
    else
      ++pos;
    let frameIndex = 0;
    let errMsg;
    loop:
    while(length > pos) {
      switch(buf[pos]) {
       case 0x21: // Extension
        log("| Extension");
        switch(buf[++pos]) {
         case 0xF9: { // Graphics Control
          log("| | Graphics Control");
          const length = buf[++pos];
          let p = 0, gceView = new Uint8Array(source, ++pos, length);
          if (buf[pos += length] !== 0) { errMsg = "missing null"; break loop; }
          if (!gif.frames[frameIndex])
            gif.frames[frameIndex] = frameObjFactory();
          let flag;
          gif.frames[frameIndex].graphicExtension = {
            disposalMethod:
              ( (gceView[p] & 16) | (gceView[p] & 8) | (gceView[p] & 4) ) >> 2,
            userInputFlag: (gceView[p] & 2) >> 1,
            transparentColorFlag: flag = gceView[p] & 1,
            delay: (gceView[++p] | (gceView[++p] << 8)) * 10,
            transparentColorIndex: flag ? gceView[++p] : (++p, 0)
          };
        } break;
         case 0xFF: { // Application
          log("| | Application");
          const length = buf[++pos];
          if (length !== 11) {
            errMsg = "app extension header of 11 byte length expected";
            break loop;
          }
          let isNetscape = true;
          for (let i = 0; length > i && isNetscape; ++i)
            isNetscape = NETSCAPE[i] === buf[1 + i + pos];
          if (isNetscape) {
            if (buf[pos += length + 2] !== 1) {
              errMsg = "invalid NETSCAPE block";
              break loop;
            }
            gif.repeat = buf[++pos] | (buf[++pos] << 8);
            if (buf[++pos] !== 0) { errMsg = "missing null"; break loop; }
          }
          else {
            while(buf[++pos] !== 0);
            ++pos;
          }
        } break;
         case 0xFE: // Comment
         case 0x01: // Plain Text
          while(buf[++pos] !== 0) pos += buf[pos];
          break;
         default:
          errMsg = "unknown extension";
          break loop;
        }
        ++pos;
        break;
       case 0x2C: { // Image Descriptor
        if (!gif.frames[frameIndex]) gif.frames[frameIndex] = frameObjFactory();
        const frameObj = gif.frames[frameIndex];
        log(`| Image Descriptor #${1+frameIndex}`);
        let localColor;
        let size = 0;
        frameObj.descriptor = {
          left: buf[++pos] | (buf[++pos] << 8),
          top: buf[++pos] | (buf[++pos] << 8),
          width: buf[++pos] | (buf[++pos] << 8),
          height: buf[++pos] | (buf[++pos] << 8),
          packed: {
            localColorTableFlag: localColor = (buf[++pos] & 128) >> 7,
            interlaceFlag: (buf[pos] & 64) >> 6,
            sortFlag: (buf[pos] & 32) >> 5,
            size: size = (buf[pos] & 4) | (buf[pos] & 2) | (buf[pos] & 1)
          }
        };
        if (localColor) {
          log("| Local Color Table");
          const colors = 2 ** (size + 1);
          const lctView = new Uint8Array(source, ++pos, colors * 3);
          const table = new Array(colors);
          for (let i = 0, p = 0; colors > i; ++i, pos += 3) {
            const color = table[i] = new Array(3);
            p = -1;
            color[++p] = lctView[i * 3 + p];
            color[++p] = lctView[i * 3 + p];
            color[++p] = lctView[i * 3 + p];
          }
          frameObj.localColorTable = table;
          --pos;
        }
        log("| Image Data");
        const lzw = buf[++pos];
        if (lzw > 8 || 2 > lzw) {
          errMsg = "invalid LZW minimum code size";
          break loop;
        }
        frameObj.minCodeSize = lzw;
        let totalLength = -1;
        const startPointer = ++pos;
        log("| | Counting total sub-block length");
        while(buf[pos] !== 0) {
          const length = buf[pos];
          totalLength += length;
          pos += length + 1;
        }
        if (totalLength < 1) {
          totalLength = 1;
        }
        log("| | Processing sub-block");
        const subBlockAccumulator = new Array(totalLength);
        let accumulatorPointer = -1;
        pos = startPointer;
        while(buf[pos] !== 0) {
          const length = buf[pos];
          for (let i = 0; length > i; ++i)
            subBlockAccumulator[++accumulatorPointer] = buf[++pos];
          ++pos;
        }
        frameObj.rawData = subBlockAccumulator;
        log(`| | Sub-block processed`);
        ++pos; log(`| Frame #${++frameIndex} processed`);
      } break;
       case 0x3B: // Tail
        log(`GIF processed in ${timer() - start} ms`);
        ++pos;
        break loop;
       default:
        errMsg = "unknown block";
        break loop;
      }
    }
    if (errMsg)
      throw new TypeError(
        errMsg +
        `0x${buf[pos].toString(16).toUpperCase().padStart(2, 0)} @ ` +
        `0x${pos.toString(16).toUpperCase().padStart(8, 0)}`
      );
    if (pos !== length)
      log(`/!\\ Additional ${length - pos} bytes of data after tail ignored`);
    return gif;
  };
  return parser;
})();
const getDisposals = frameObj => frameObj.graphicExtension.disposalMethod;
const getDelays = frameObj => frameObj.graphicExtension.delay - 1;
const copyColorsTransparent = async (source, target, fWidth, fHeight, oLeft, oTop, cWidth, flag) => {
  for (let row = 0, pointer = -1; fHeight > row; ++row)
  for (let column = 0; fWidth > column; ++column) {
    let offset = (column + oLeft + (row + oTop) * cWidth) * 4;
    if (flag && source[pointer + 4] === 0) {
      pointer += 4;
      continue;
    }
    target[  offset] = source[++pointer];
    target[++offset] = source[++pointer];
    target[++offset] = source[++pointer]; ++pointer;
    target[++offset] = flag ? source[pointer] : 255;
  }
};
const copyColors = async (source, target, fWidth, fHeight, oLeft, oTop, cWidth) => {
  for (let row = 0, pointer = -1; fHeight > row; ++row)
  for (let column = 0; fWidth > column; ++column) {
    let offset = (column + oLeft + (row + oTop) * cWidth) * 4;
    target[++pointer] = source[  offset];
    target[++pointer] = source[++offset];
    target[++pointer] = source[++offset];
    target[++pointer] = source[++offset];
  }
};
const messageHandler = async e => {
  const o = await GIF(
    await (
      await fetch(e.data, { headers: { pragma: "no-cache", "cache-control": "no-cache" }})
    ).arrayBuffer()
  );
  const frameCount = o.frames.length;
  const compiledFrames = new Array(frameCount);
  const delays = o.frames.map(getDelays);
  const canvasWidth = o.descriptor.width;
  const canvasHeight = o.descriptor.height;
  const disposals = o.frames.map(getDisposals);
  const canvas = new Uint8ClampedArray(canvasWidth * canvasHeight * 4);
  let index = 0;
  do {
    const frame = o.frames[index];
    const transparentColorFlag = frame.graphicExtension && frame.graphicExtension.transparentColorFlag;
    const [
      {
        data: frameImageData,
        width: frameWidth,
        height: frameHeight
      },
      offsetLeft,
      offsetTop
    ] = await o.toImageData(index);
    switch(disposals[index]) {
     case 2:
      for (let row = 0; frameHeight > row; ++row)
      for (let column = 0; frameWidth > column; ++column) {
        let offset = (column + offsetLeft + (row + offsetTop) * canvasWidth) * 4;
        canvas[  offset] = 0;
        canvas[++offset] = 0;
        canvas[++offset] = 0;
        canvas[++offset] = transparentColorFlag ? 0 : 255;
      } break;
     case 3:
      if (index > 0) {
        const [
          {
            data: frameImageData,
            width: frameWidth,
            height: frameHeight
          },
          offsetLeft,
          offsetTop
        ] = compiledFrames[index - 1];
        await copyColors(frameImageData, canvas, frameWidth, frameHeight, offsetLeft, offsetTop, canvasWidth);
      } break;
    }
    await copyColorsTransparent(frameImageData, canvas, frameWidth, frameHeight, offsetLeft, offsetTop, canvasWidth, transparentColorFlag);
    await copyColors(canvas, frameImageData, frameWidth, frameHeight, offsetLeft, offsetTop, canvasWidth);
    compiledFrames[index] = [new ImageData(frameImageData, frameWidth, frameHeight), offsetLeft, offsetTop];
  } while(++index < frameCount);
  postMessage([compiledFrames, delays, canvasWidth, canvasHeight]);
};
(global => {
  global.onmessage = messageHandler;
  global.onerror = e => {
    postMessage(["log", e]);
  };
})((() => this)());
